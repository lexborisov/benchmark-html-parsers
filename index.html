<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Benchmark. Analyzing and Testing Current HTML Parsers</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <script src="js/jquery-2.2.1.min.js"></script>
    <script src="js/work.js"></script>
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name"></h1>
      <h2 class="project-tagline">Benchmark. Analyzing and Testing Current HTML Parsers</h2>
    </section>

    <section class="main-content">
        
        <img src="img/logo.jpg">
      <p>Hi there!</p>

<p>After posting <a href="https://www.reddit.com/r/programming/comments/49yqal/fast_html_parser_on_pure_c_with_posix_threads/">the previous article</a>, I've got lots of emails asking to show and prove how one solution is better than another.<br>
I enthusiastically got down to comparisons, but it's all usually a little bit trickier than at first sight.</p>

<p>Yes, in this article I suggest taking out and measuring all the parsers!</p>

<h3>
<a id="lets-get-started" class="anchor" href="#lets-get-started" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Let's get started!</h3>

<p>Before comparing anything, we've got to figure out: what are we really going to compare?! HTML parsers, but what is it?</p>

<p>An HTML parser is:</p>
<ol>
 <li>Tokenizer — breaking text down into tokens</li>
 <li>Tree Builder — placing tokens in “correct positions” in a tree</li>
 <li>Tree follow-up</li>
</ol>

<p>Someone out of the blue might say: “There's no need to build a tree for HTML parsing, it's enough to get tokens.” Unfortunately, they're wrong.<br>
Actually, for correct HTML tokenization, we should have a tree at hand. Points 1 and 2 go as one.</p>

<p>Here're 2 examples:</p>

<p>Example 1:</p>

<div class="highlight highlight-text-html-basic"><pre>&lt;<span class="pl-ent">svg</span>&gt;&lt;<span class="pl-ent">desc</span>&gt;&lt;<span class="pl-ent">math</span>&gt;<span class="pl-s1">&lt;<span class="pl-ent">style</span>&gt;&lt;<span class="pl-ent">a</span>&gt;</span></pre></div>

<p>The result of correct processing:</p>

<div class="highlight highlight-text-html-basic"><pre>&lt;<span class="pl-ent">html</span>&gt;
  &lt;<span class="pl-ent">head</span>&gt;
  &lt;<span class="pl-ent">body</span>&gt;
    &lt;<span class="pl-ent">svg:svg</span>&gt;
      &lt;<span class="pl-ent">desc:svg</span>&gt;
        &lt;<span class="pl-ent">math:math</span>&gt;
<span class="pl-s1">          &lt;<span class="pl-ent">style</span><span class="pl-e">:math</span>&gt;</span>
<span class="pl-s1">            &lt;<span class="pl-ent">a</span>:math&gt;</span></pre></div>

<p>Example 2:</p>

<div class="highlight highlight-text-html-basic"><pre>&lt;<span class="pl-ent">svg</span>&gt;&lt;<span class="pl-ent">desc</span>&gt;<span class="pl-s1">&lt;<span class="pl-ent">style</span>&gt;&lt;<span class="pl-ent">a</span>&gt;</span></pre></div>

<p>The result of correct processing:</p>

<div class="highlight highlight-text-html-basic"><pre>&lt;<span class="pl-ent">html</span>&gt;
  &lt;<span class="pl-ent">head</span>&gt;
  &lt;<span class="pl-ent">body</span>&gt;
    &lt;<span class="pl-ent">svg:svg</span>&gt;
      &lt;<span class="pl-ent">desc:svg</span>&gt;
<span class="pl-s1">        &lt;<span class="pl-ent">style</span>&gt;</span>
<span class="pl-s1">          &lt;-text&gt;: &lt;<span class="pl-ent">a</span>&gt;</span></pre></div>

<p>After “:” comes namespace, if unspecified then html.</p>

<p>As the examples show, the STYLE element behaves differently — depending on its position. The 1st variant has the element A, while in the 2nd it's already a text element. Here I can give examples with “frameset”, “script”, “title”... and their different behavior, but I guess you have the general idea.</p>

<p>Now we can draw a conclusion that breakdown into tokens can't be correctly done without building an HTML tree. Consequently, HTML parsing can't be done without at least 2 stages: tokenization and tree building.<br>
As to the terms: “strict”, “failing the spec”, “light”, “HTML 4”, and the like... I'm sure one can safely replace all these terms with 1: “doesn't process correctly.” It's all absurd. </p>

<h3>
<a id="how-and-what-to-compare" class="anchor" href="#how-and-what-to-compare" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How and What to Compare?</h3>

<p>Here comes the point. An HTML parser is too proud a name for everything. Moreover, even those dubbed HTML tokenizers aren't actually such.<br>
With all the parsers at hand, I wonder what and with what to compare? So let's compare true parsers:</p>

<p>MyHTML, HTML5Lib, HTML5Ever, Gumbo.</p>

<p>It's them that comply with the latest spec, and their result will match what we can see in present-day browsers.<br>
Untrue parsers (failing the spec) may greatly vary in speed / memory, but it's a fat lot of use since they process a document incorrectly.<br>
No runarounds like “a parser for HTML 4” will count. Things always change, and we've got to keep pace with them.</p>

<p>I should say HTML5Ever isn't an absolutely true parser. Authors write it doesn't pass all html5lin-test-tree-builder tests for correct tree building. It became true for its efforts.<br>
At the moment of writing this article, HTML5Lib wasn't building the tree for some HTML formats correctly. But it's all bugs the authors will hopefully fix.</p>

<p>Let's measure time/memory for 466 HTML files by Alexa TOP500. 466, not 500, because not all websites are running or open their content.</p>

<p>For each page, a fork will be made with the stages:</p>
<ol>
 <li>Complete parser initialization</li>
 <li>1 page parsing</li>
 <li>Resource deallocation</li>
</ol>

<p>There'll also be an ex vivo test — running all the pages with 1 object, where possible. Everything will occur sequentially.</p>

<h3>
<a id="down-to-the-tests" class="anchor" href="#down-to-the-tests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Down to the tests!</h3>

<p>The following have been qualified for our tests: MyHTML, HTML5Ever, Gumbo.</p>

<p>Sadly, HTML5Lib failed testing. A prerun proved it's much slower than the others. There's no use comparing it — it's written on Python and is very, very slow.</p>

<p>MyHTML and Gumbo are written on C. HTML5Ever — it’s Rust. I'm not good in Rust, not yet, so I asked Alexey Voznyuk to help me. Alexey agreed (kudos to him!) and made a C wrapper for parser testing.</p>

<p>Runtime test results:
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_0_500.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_0_500_990.png" alt="time benchmark html parsers"></a></p>

<p>Resource consumption test results:
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_0_500.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_0_500_990.png" alt="memory benchmark html parsers"></a></p>

<p><span class="spoiler_title" id="title-time-100">Runtime test results divided by 100</span></p>
<div class="spoiler_text" id="data-time-100">
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_0_100.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_0_100_990.png" alt=""></a>
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_100_200.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_100_200_990.png" alt=""></a>
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_200_300.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_200_300_990.png" alt=""></a>
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_300_400.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_300_400_990.png" alt=""></a>
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_400_500.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/time/benchmark_400_500_990.png" alt=""></a>
</div>

<p><span class="spoiler_title" id="title-mem-100">Resource consumption results divided by 100</span></p>
<div class="spoiler_text" id="data-mem-100">
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_0_100.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_0_100_990.png" alt=""></a>
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_100_200.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_100_200_990.png" alt=""></a>
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_200_300.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_200_300_990.png" alt=""></a>
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_300_400.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_300_400_990.png" alt=""></a>
<a href="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_400_500.png"><img src="https://raw.githubusercontent.com/lexborisov/benchmark-html-persers/master/Results/mem/benchmark_400_500_990.png" alt=""></a>
</div>

<p>Ex vivo test result. Running all (466) pages in 1 process:</p>

<div class="highlight highlight-text-html-basic"><pre>
<em>MyHTML</em>:
    <b style="padding-left: 40px;">Overall time:</b> 0.50890;
    <b style="padding-left: 40px;">Memory at the beginning:</b> 1052672;
    <b style="padding-left: 40px;">Memory at the end:</b> 32120832

<em>MyHTML Single Mode</em>:
    <b style="padding-left: 40px;">Overall time:</b> 0.72160;
    <b style="padding-left: 40px;">Memory at the beginning:</b> 1052672;
    <b style="padding-left: 40px;">Memory at the end:</b> 31805440

<em>Gumbo</em>:
    <b style="padding-left: 40px;">Overall time:</b> 6.12951;
    <b style="padding-left: 40px;">Memory at the beginning:</b> 1052672;
    <b style="padding-left: 40px;">Memory at the end:</b> 29319168

<em>HTML5Ever</em>:
    <b style="padding-left: 40px;">Overall time:</b> 4.50536;
    <b style="padding-left: 40px;">Memory at the beginning:</b> 1052672;
    <b style="padding-left: 40px;">Memory at the end:</b> 30715904
</pre></div>

<h3>
<a id="totals" class="anchor" href="#totals" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Totals</h3>

<p>The undisputed leader in speed is MyHTML. Gumbo is the memory leader, not surprisingly. HTML5Ever has fallen flat, to put it mildly. The latter was neither quick nor good in memory, it can be used only on Rust.</p>

<p>The ex vivo test has shown little differences in memory, although really gigantic ones in speed.</p>

<h3>
<a id="things-used" class="anchor" href="#things-used" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Things used</h3>

<p>Hardware: </p>

<ul>
<li>Intel® Core(TM) i7-3615QM CPU @ 2.30GHz</li>
<li>8 Gb 1600 MHz DDR3</li>
</ul>

<p>Software: </p>

<ul>
<li>Darwin MBP-Alexander 15.3.0 Darwin Kernel Version 15.3.0: Thu Dec 10 18:40:58 PST 2015; root:xnu-3248.30.4~1/RELEASE_X86_64 x86_64</li>
<li>Apple LLVM version 7.0.2 (clang-700.1.81)</li>
<li>Target: x86_64-apple-darwin15.3.0</li>
<li>Thread model: posix</li>
</ul>

<h3>
<a id="links" class="anchor" href="#links" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Links</h3>
<p>
<a href="https://github.com/lexborisov/benchmark-html-persers/tree/master">Benchmark code</a><br>
<a href="https://github.com/lexborisov/benchmark-html-persers/tree/master/Results">Images and CSV</a><br>
<a href="https://github.com/lexborisov/myhtml">MyHTML</a>, <a href="https://github.com/google/gumbo-parser">Gumbo</a>, <a href="https://github.com/servo/html5ever">HTML5Ever</a><br>
<a href="https://github.com/swizard0/html2html_lib">API for HTML5Event</a> by Alexey<br>
</p>

<p><em><strong>Thanks for reading!</strong></em></p>

<h3>
<a id="ps-by-myhtmls-author" class="anchor" href="#ps-by-myhtmls-author" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>P.S. by MyHTML's author</h3>

<p>As MyHTML's author, I found it morally hard doing such testing. However, I tried to deal with the matter with greatest responsibility and treat each parser as my own.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/lexborisov/benchmark-html-persers">Benchmark-html-persers</a> is maintained by <a href="https://github.com/lexborisov">lexborisov</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-74753465-1', 'auto');
  ga('send', 'pageview');

</script>
  </body>
</html>
